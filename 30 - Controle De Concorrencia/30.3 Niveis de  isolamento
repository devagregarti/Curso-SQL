Slide 1: IntroduÃ§Ã£o aos NÃ­veis de Isolamento
TÃ­tulo: O que sÃ£o nÃ­veis de isolamento?

Definem como e quando as alteraÃ§Ãµes feitas por uma transaÃ§Ã£o se tornam visÃ­veis para outras.

Quanto maior o isolamento, mais consistÃªncia, mas tambÃ©m mais custo e lentidÃ£o.

SQL define 4 nÃ­veis: cada um evita certos problemas de concorrÃªncia.

Slide 2: Os 3 problemas clÃ¡ssicos
TÃ­tulo: O que pode dar errado sem isolamento?

Dirty Read: ler dados nÃ£o confirmados por outra transaÃ§Ã£o.

Non-repeatable Read: valor muda entre duas leituras na mesma transaÃ§Ã£o.

Phantom Read: nÃºmero de registros muda (ex: SELECT COUNT(*) muda).

Slide 3: Os 4 NÃ­veis de Isolamento (SQL ANSI)
TÃ­tulo: NÃ­veis de isolamento definidos pelo padrÃ£o SQL

Read Uncommitted

Read Committed (padrÃ£o no PostgreSQL)

Repeatable Read

Serializable

Slide 4: Read Uncommitted
TÃ­tulo: NÃ­vel mais baixo: Read Uncommitted

Permite dirty reads.

Quase nunca usado em PostgreSQL (nÃ£o Ã© suportado).

Exemplo:

sql
Copy
Edit
BEGIN;
SELECT saldo FROM contas;
-- Pode ler algo que serÃ¡ desfeito por outra transaÃ§Ã£o
Slide 5: Read Committed (padrÃ£o no PostgreSQL)
TÃ­tulo: Read Committed: seguro e rÃ¡pido

Leitura sÃ³ enxerga dados confirmados (committed).

Mas a mesma query pode dar resultados diferentes dentro da mesma transaÃ§Ã£o.

Evita dirty reads, mas nÃ£o evita non-repeatable ou phantom reads.

Slide 6: Exemplo - Read Committed
TÃ­tulo: O que acontece na prÃ¡tica?

sql
Copy
Edit
BEGIN;
SELECT saldo FROM contas WHERE id = 1;
-- Retorna 100

-- Outra transaÃ§Ã£o altera para 80 e faz COMMIT

SELECT saldo FROM contas WHERE id = 1;
-- Agora retorna 80 (mudou durante a transaÃ§Ã£o!)
Slide 7: Repeatable Read
TÃ­tulo: Repeatable Read: estabilidade nas leituras

Todas as leituras dentro da transaÃ§Ã£o veem a mesma foto do banco.

Garante que dados lidos nÃ£o mudam atÃ© o fim da transaÃ§Ã£o.

Evita dirty e non-repeatable reads.

Mas phantoms ainda podem ocorrer no padrÃ£o ANSI. No PostgreSQL, phantoms sÃ£o evitados.

Slide 8: Exemplo - Repeatable Read
sql
Copy
Edit
BEGIN ISOLATION LEVEL REPEATABLE READ;
SELECT * FROM contas WHERE saldo > 100;

-- Outra transaÃ§Ã£o insere nova conta com saldo = 200 e COMMIT

SELECT * FROM contas WHERE saldo > 100;
-- Mesmo assim, o novo registro nÃ£o aparece!
Snapshot fixo durante a transaÃ§Ã£o.

Slide 9: Serializable
TÃ­tulo: Serializable: o mais seguro (e pesado)

Emula execuÃ§Ã£o como se as transaÃ§Ãµes fossem em sÃ©rie.

Nenhuma interferÃªncia entre transaÃ§Ãµes.

Mais bloqueios, risco de erros de serializaÃ§Ã£o (falha com sugestÃ£o de tentar de novo).

Slide 10: Exemplo - Serializable
sql
Copy
Edit
BEGIN ISOLATION LEVEL SERIALIZABLE;
-- LÃª saldo da conta

-- Outra transaÃ§Ã£o modifica saldo e COMMIT

-- Ao tentar COMMIT:
ERROR: could not serialize access due to concurrent update
Slide 11: ComparaÃ§Ã£o geral
TÃ­tulo: Comparando os nÃ­veis

NÃ­vel	Dirty Read	Non-repeatable	Phantom	Performance
Read Uncommitted	âœ…	âœ…	âœ…	ğŸš€ Muito rÃ¡pido
Read Committed	âŒ	âœ…	âœ…	âš¡ RÃ¡pido
Repeatable Read	âŒ	âŒ	âŒ*	ğŸ¢ MÃ©dio
Serializable	âŒ	âŒ	âŒ	ğŸŒ Lento, mais seguro

* PostgreSQL evita phantoms em Repeatable Read.

Slide 12: ConclusÃ£o e boas prÃ¡ticas
TÃ­tulo: Quando usar cada um?

Read Committed: padrÃ£o, bom equilÃ­brio (usar na maioria dos casos).

Repeatable Read: quando vocÃª precisa de consistÃªncia maior sem phantoms.

Serializable: para transaÃ§Ãµes crÃ­ticas e com validaÃ§Ãµes complexas.

Use transaÃ§Ãµes curtas e objetivas para evitar conflitos e bloqueios.

