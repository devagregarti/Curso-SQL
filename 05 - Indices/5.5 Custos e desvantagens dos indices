â— Desvantagens e custos do uso de Ã­ndices (com exemplos prÃ¡ticos)
ğŸ“Œ 1. Ãndices ocupam espaÃ§o em disco
Cada Ã­ndice criado gera uma estrutura extra que precisa ser armazenada.

Em tabelas grandes com muitos Ã­ndices, isso pode triplicar o uso de disco.

ğŸ§  Exemplo prÃ¡tico:

sql
Copy
Edit
CREATE INDEX idx_nome ON clientes(nome);
CREATE INDEX idx_email ON clientes(email);
CREATE INDEX idx_telefone ON clientes(telefone);
Se a tabela clientes tiver milhÃµes de linhas, cada Ã­ndice adiciona centenas de MBs â€” ou atÃ© GBs.

ğŸ¢ 2. Ãndices desaceleram INSERTs, UPDATEs e DELETEs
Toda vez que uma linha Ã© modificada, o banco precisa atualizar todos os Ã­ndices relacionados.

Muitos Ã­ndices = operaÃ§Ãµes de escrita mais lentas.

ğŸ§  Exemplo prÃ¡tico:

sql
Copy
Edit
UPDATE produtos SET preco = preco * 1.1;
Se preco estiver indexado, o PostgreSQL precisa atualizar o Ã­ndice para todas as linhas modificadas.

âŒ 3. Ãndice mal utilizado pode nunca ser usado
Um Ã­ndice sÃ³ Ã© usado se a consulta conseguir se beneficiar dele.

Em tabelas pequenas, o otimizador prefere escanear tudo do que acessar o Ã­ndice.

ğŸ§  Exemplo prÃ¡tico:

sql
Copy
Edit
SELECT * FROM categorias WHERE nome = 'Bebidas';
Se a tabela categorias tiver 10 linhas, o Ã­ndice serÃ¡ ignorado. SÃ³ desperdiÃ§a espaÃ§o.

âš ï¸ 4. Ãndices em colunas com muitos valores repetidos sÃ£o pouco eficazes
Se quase todas as linhas tÃªm o mesmo valor, o Ã­ndice nÃ£o ajuda o otimizador.

ğŸ§  Exemplo prÃ¡tico:

sql
Copy
Edit
SELECT * FROM usuarios WHERE ativo = true;
Se 95% dos usuÃ¡rios forem ativos, o Ã­ndice em ativo quase nunca serÃ¡ usado.

ğŸ”€ 5. Ãndices em colunas que mudam com frequÃªncia sÃ£o problemÃ¡ticos
Exigem reescrita constante no Ã­ndice â†’ impacto em performance.

ğŸ§  Exemplo prÃ¡tico:

sql
Copy
Edit
UPDATE pedidos SET status = 'Processado' WHERE id = 123;
Se status for indexado e mudar com frequÃªncia, o Ã­ndice vira um gargalo.

âœ… Quando um Ã­ndice VALE a pena? (passo a passo para decidir)
ğŸ” Passo 1: A coluna Ã© usada com frequÃªncia em WHERE, JOIN, ORDER BY, GROUP BY?
Sim â†’ Continue

NÃ£o â†’ Provavelmente nÃ£o precisa de Ã­ndice

ğŸ” Passo 2: A tabela tem MUITAS linhas? (milhares ou milhÃµes)
Sim â†’ Ãndice ajuda

NÃ£o â†’ Pode ser desnecessÃ¡rio

ğŸ” Passo 3: A coluna tem alta seletividade?
Ou seja, muitos valores diferentes

Ex: cpf, email, id â†’ Boa seletividade

Ex: ativo, status â†’ Baixa seletividade â†’ Ã­ndice fraco

ğŸ” Passo 4: A coluna muda pouco?
Sim â†’ Boa candidata

NÃ£o â†’ Cuidado! Evite indexar colunas que mudam constantemente

ğŸ” Passo 5: Teste com EXPLAIN ANALYZE
Antes de criar o Ã­ndice, rode a consulta com:

sql
Copy
Edit
EXPLAIN ANALYZE SELECT ... WHERE coluna = valor;
Depois crie o Ã­ndice e rode de novo. Veja se o plano mudou, se ele usa o Ã­ndice e se o tempo melhorou.

ğŸ§  Dica bÃ´nus: Use Ã­ndices parciais ou multicoluna com critÃ©rio
Ãndice parcial: sÃ³ para linhas que interessam

sql
Copy
Edit
CREATE INDEX idx_ativos ON usuarios(ativo) WHERE ativo = true;
Ãndice multicoluna: Ãºtil quando a consulta usa mais de uma coluna combinada

sql
Copy
Edit
CREATE INDEX idx_nome_data ON vendas(cliente_id, data_compra);