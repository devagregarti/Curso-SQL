âš ï¸ Erros Comuns ao Usar Constraints em SQL
Mesmo quem jÃ¡ tem experiÃªncia com SQL pode cometer erros ao usar constraints. Aqui estÃ£o os mais comuns, com explicaÃ§Ãµes e como evitÃ¡-los:

âŒ 1. Adicionar uma Constraint em Dados que JÃ¡ EstÃ£o Errados
sql
Copy
Edit
ALTER TABLE clientes
ADD CONSTRAINT chk_idade CHECK (idade >= 18);
ğŸ’¥ Erro: se houver registros com idade menor que 18, o comando falha.

âœ… SoluÃ§Ã£o:

Verifique os dados antes de adicionar:

sql
Copy
Edit
SELECT * FROM clientes WHERE idade < 18;
âŒ 2. NÃ£o Dar Nome Ã  Constraint (e depois nÃ£o conseguir removÃª-la)
sql
Copy
Edit
ALTER TABLE clientes
ADD CHECK (idade >= 18);  -- sem nome!
Depois fica difÃ­cil remover porque o nome da constraint foi gerado automaticamente (ex: clientes_idade_check).

âœ… SoluÃ§Ã£o:

Sempre dÃª nomes explÃ­citos:

sql
Copy
Edit
ADD CONSTRAINT chk_idade_minima CHECK (idade >= 18);
âŒ 3. Criar Muitos Ãndices por causa de Constraints UNIQUE
Cada UNIQUE cria automaticamente um Ã­ndice. Se exagerar, o banco fica lento para INSERT e UPDATE.

âœ… SoluÃ§Ã£o:

Use UNIQUE apenas onde for necessÃ¡rio de verdade (como email, cpf, etc.).

âŒ 4. Esquecer o NOT NULL com DEFAULT
sql
Copy
Edit
status TEXT DEFAULT 'ativo'
ğŸ’¥ Aqui o banco permite valores nulos se vocÃª nÃ£o usar NOT NULL.

âœ… Correto:

sql
Copy
Edit
status TEXT NOT NULL DEFAULT 'ativo';
âŒ 5. Definir uma FOREIGN KEY sem garantir que os dados jÃ¡ existem na tabela referenciada
sql
Copy
Edit
ALTER TABLE pedidos
ADD CONSTRAINT fk_cliente FOREIGN KEY (cliente_id)
REFERENCES clientes(id);
ğŸ’¥ Se cliente_id tiver valores que nÃ£o existem na tabela clientes, o banco vai recusar a criaÃ§Ã£o.

âœ… SoluÃ§Ã£o:

Verifique antes:

sql
Copy
Edit
SELECT cliente_id FROM pedidos
WHERE cliente_id NOT IN (SELECT id FROM clientes);
ğŸ§  Dica Final:
Sempre que for usar ou alterar constraints:

Verifique os dados com SELECT antes.

DÃª nomes claros.

FaÃ§a testes em ambiente separado (dev/staging) se estiver em produÃ§Ã£o.