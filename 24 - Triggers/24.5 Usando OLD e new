üîç Usando OLD e NEW em Triggers
‚úÖ O que s√£o?
OLD representa o registro antes da opera√ß√£o (dispon√≠vel em triggers de UPDATE e DELETE).

NEW representa o registro depois da opera√ß√£o (dispon√≠vel em triggers de INSERT e UPDATE).

Quando usar:
Evento	OLD dispon√≠vel?	NEW dispon√≠vel?
INSERT	N√£o	Sim
UPDATE	Sim	Sim
DELETE	Sim	N√£o

üõ†Ô∏è Exemplo pr√°tico
Imagine a tabela clientes:

sql
Copiar
Editar
CREATE TABLE clientes (
  id SERIAL PRIMARY KEY,
  nome TEXT,
  email TEXT
);
Queremos criar uma trigger que registre mudan√ßas no email quando um cliente atualizar seu cadastro.

Fun√ß√£o da trigger usando OLD e NEW:
sql
Copiar
Editar
CREATE OR REPLACE FUNCTION log_email_change()
RETURNS TRIGGER AS $$
BEGIN
  -- Verifica se o email foi alterado
  IF NEW.email IS DISTINCT FROM OLD.email THEN
    INSERT INTO log_email_update(cliente_id, email_antigo, email_novo, data_alteracao)
    VALUES (OLD.id, OLD.email, NEW.email, now());
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
Criando a trigger:
sql
Copiar
Editar
CREATE TRIGGER trigger_email_update
AFTER UPDATE ON clientes
FOR EACH ROW
EXECUTE FUNCTION log_email_change();
‚ö†Ô∏è Pontos importantes
OLD √© usado para acessar valores antes da modifica√ß√£o.

NEW √© usado para acessar valores ap√≥s a modifica√ß√£o.

Em triggers de INSERT, s√≥ existe NEW.

Em triggers de DELETE, s√≥ existe OLD.

Em triggers de UPDATE, temos ambos OLD e NEW.

üß† Dica
Sempre use IS DISTINCT FROM para comparar valores, pois assim voc√™ evita problemas quando o valor for NULL.
