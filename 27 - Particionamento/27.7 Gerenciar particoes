Aula: Gerenciando PartiÃ§Ãµes no PostgreSQL
âœ… O que significa â€œgerenciar partiÃ§Ãµesâ€?
Ã‰ o processo de:

Adicionar novas partiÃ§Ãµes

Remover partiÃ§Ãµes

Alterar partiÃ§Ãµes existentes

Verificar se os dados estÃ£o sendo distribuÃ­dos corretamente

Fazer manutenÃ§Ã£o preventiva na estrutura da tabela particionada

ğŸ“Œ Lembrando: o que Ã© uma partiÃ§Ã£o?
Ã‰ uma subdivisÃ£o da tabela principal

Pode ser criada com base em valores fixos (LIST), intervalos (RANGE) ou distribuiÃ§Ã£o automÃ¡tica (HASH)

O PostgreSQL coloca os dados na partiÃ§Ã£o certa, conforme a regra definida

ğŸ§± 1. Adicionando novas partiÃ§Ãµes
â–¶ï¸ Para tabelas com particionamento por RANGE:
sql
Copy
Edit
CREATE TABLE vendas_2025 PARTITION OF vendas
FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');
VocÃª estÃ¡ dizendo: tudo de 2025 vai nessa partiÃ§Ã£o

Importante quando um novo ano comeÃ§a

â–¶ï¸ Para tabelas com particionamento por LIST:
sql
Copy
Edit
CREATE TABLE vendas_rn PARTITION OF vendas
FOR VALUES IN ('RN');  -- Estado do Rio Grande do Norte
Ãštil se a empresa comeÃ§ou a vender em um novo estado

â–¶ï¸ Para tabelas com particionamento por HASH:
sql
Copy
Edit
CREATE TABLE clientes_hash_4 PARTITION OF clientes
FOR VALUES WITH (MODULUS 5, REMAINDER 4);
AtenÃ§Ã£o: mudar o nÃºmero de partiÃ§Ãµes no HASH exige reorganizar as antigas â€” o PostgreSQL nÃ£o faz isso sozinho

ğŸ§¹ 2. Removendo uma partiÃ§Ã£o
VocÃª pode remover uma partiÃ§Ã£o se ela nÃ£o for mais necessÃ¡ria.

sql
Copy
Edit
DROP TABLE vendas_2022;
âš ï¸ Isso apaga todos os dados daquela partiÃ§Ã£o!

ğŸ§ª 3. Verificando as partiÃ§Ãµes existentes
Para ver as partiÃ§Ãµes de uma tabela:

sql
Copy
Edit
SELECT relname AS particao
FROM pg_inherits
JOIN pg_class ON pg_inherits.inhrelid = pg_class.oid
WHERE inhparent = 'vendas'::regclass;
Lista os nomes das partiÃ§Ãµes da tabela vendas

âœï¸ 4. Verificando em qual partiÃ§Ã£o os dados estÃ£o
sql
Copy
Edit
SELECT tableoid::regclass AS particao, *
FROM vendas
WHERE data_venda = '2023-10-15';
tableoid::regclass mostra o nome real da partiÃ§Ã£o de onde o dado veio

ğŸ› ï¸ 5. Modificar uma partiÃ§Ã£o (renomear, adicionar Ã­ndice, etc.)
ğŸ” Renomear uma partiÃ§Ã£o:
sql
Copy
Edit
ALTER TABLE vendas_2023 RENAME TO vendas_ano_2023;
â• Criar um Ã­ndice em uma partiÃ§Ã£o especÃ­fica:
sql
Copy
Edit
CREATE INDEX idx_data_venda_2023 ON vendas_2023 (data_venda);
ğŸ§¯ 6. Criar uma partiÃ§Ã£o DEFAULT (caso ainda nÃ£o exista)
Evita erro ao inserir dados que nÃ£o se encaixam em nenhuma outra partiÃ§Ã£o.

sql
Copy
Edit
CREATE TABLE vendas_outras PARTITION OF vendas DEFAULT;
ğŸš¨ 7. O que acontece se tentar inserir dados sem uma partiÃ§Ã£o correta?
Exemplo: inserindo um pedido com data de 2026, mas sÃ³ hÃ¡ partiÃ§Ãµes atÃ© 2025:

sql
Copy
Edit
INSERT INTO vendas (data_venda, cliente) VALUES ('2026-03-01', 'JoÃ£o');
âŒ Resultado: erro, a nÃ£o ser que haja uma partiÃ§Ã£o DEFAULT.

ğŸ” 8. Movendo dados de uma partiÃ§Ã£o para outra (caso necessÃ¡rio)
NÃ£o Ã© automÃ¡tico, vocÃª precisa:

Copiar os dados

Inserir na nova partiÃ§Ã£o

Remover da antiga

Exemplo:

sql
Copy
Edit
INSERT INTO vendas (data_venda, cliente)
SELECT data_venda, cliente FROM vendas_2023
WHERE data_venda >= '2024-01-01';

DELETE FROM vendas_2023
WHERE data_venda >= '2024-01-01';
ğŸ“Œ Dica final
Mantenha uma rotina de revisÃ£o da estrutura de partiÃ§Ãµes:

Verifique se hÃ¡ necessidade de criar novas

Apague partiÃ§Ãµes antigas sÃ³ se tiver certeza de que nÃ£o precisarÃ¡ mais dos dados

Use Ã­ndices locais nas partiÃ§Ãµes para melhorar a performance

ğŸ”š ConclusÃ£o
Gerenciar partiÃ§Ãµes Ã© parte essencial para manter a tabela organizada e rÃ¡pida

PostgreSQL dÃ¡ bastante controle, mas exige atenÃ§Ã£o manual

Bons hÃ¡bitos de manutenÃ§Ã£o evitam erros futuros e mantÃªm o sistema saudÃ¡vel

